''' Imports '''
import pickle
import numpy
import keras.models
from music21 import instrument, note, stream, chord  # python music


NOTES_PATH = './notes'  # path to file containing notes
MODEL_PATH = './model'  # path to saved model


def gen_music(file_name):
  ''' Outputs our new midi file '''
  with open(NOTES_PATH, 'rb') as filepath:
    notes = pickle.load(filepath)

  pitches = sorted(set(n for n in notes))

  num_pitches = len(set(notes))

  input, normal_input = prep_data(notes, num_pitches, pitches)

  model = keras.models.load_model(MODEL_PATH)

  predictions = gen_notes(model, input, pitches, num_pitches)

  gen_midi(predictions, file_name)


def prep_data(notes, num_pitches, pitches):
  ''' convert our string notes into integers readable by the network '''

  #  alter this to alter results
  lookback = 100

  #  the mapping of pitch to integer
  note_dic = dict((note, n) for n, note in enumerate(pitches))

  training_samples = []

  for i in range(0, len(notes) - lookback, 1):
    cur_samples = notes[i:i + lookback]
    training_samples.append([note_dic[samp] for samp in cur_samples])

  n_samples = len(training_samples)

  #  reshape
  normal_training_samples = numpy.reshape(training_samples, (n_samples, lookback, 1))

  #  normalize
  normal_training_samples = normal_training_samples / float(num_pitches)


  return training_samples, normal_training_samples


def gen_notes(model, input, pitches, num_pitches):
  # get starting point randomly
  start = numpy.random.randint(0, len(input)-1)

  note_dic = dict((n, note) for n, note in enumerate(pitches))
  
  pattern = input[start]

  output = []
  for note_ind in range(500):  # 500 is the amount of notes we want to predict. Change for different song duration.
    prediction_input = numpy.reshape(pattern, (1, len(pattern), 1))
    prediction_input = prediction_input / float(num_pitches)

    cur_predict = model.predict(prediction_input, verbose=1)

    prediction_index = numpy.argmax(cur_predict)

    try:
        result = note_dic[prediction_index]
    except KeyError:
        print('error')
        continue
    output.append(result)

    pattern.append(prediction_index)  # take our prediction and make it a part of our next input

    pattern = pattern[1:len(pattern)]

  return output


def gen_midi(prediction_output, file_name):
    '''take model output and generate playable midi'''
    offset = 0
    output_notes = []

    # create note and chord objects based on the values generated by the model
    for pattern in prediction_output:
        # pattern is a chord
        if ('.' in pattern) or pattern.isdigit():
            notes_in_chord = pattern.split('.')
            notes = []
            for current_note in notes_in_chord:
                new_note = note.Note(int(current_note))
                new_note.storedInstrument = instrument.Piano()
                notes.append(new_note)
            new_chord = chord.Chord(notes)
            new_chord.offset = offset
            output_notes.append(new_chord)
        # pattern is a note
        else:
            new_note = note.Note(pattern)
            new_note.offset = offset
            new_note.storedInstrument = instrument.Piano()
            output_notes.append(new_note)

        # increase offset each iteration so that notes do not stack
        offset += 0.5

    midi_stream = stream.Stream(output_notes)

    midi_stream.write('midi', fp=f'./playlist/{file_name}.mid')


if __name__ == '__main__':
    for i in range(10):
        file_name = f'piano_ai_{i}'
        gen_music(file_name)
